% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fviz_cluster.R
\name{fviz_cluster}
\alias{fviz_cluster}
\alias{fviz_gap_stat}
\alias{fviz_nbclust}
\alias{fviz_silhouette}
\title{Visualize clustering results}
\usage{
fviz_cluster(object, data = NULL, stand = TRUE, geom = c("point", "text"),
  show.clust.cent = TRUE, frame = TRUE, frame.type = "convex",
  frame.level = 0.95, frame.alpha = 0.2, pointsize = 2, labelsize = 4,
  jitter = list(what = "label", width = NULL, height = NULL),
  outlier.color = "black", outlier.shape = 19)

fviz_silhouette(sil.obj, label = FALSE, print.summary = TRUE)

fviz_nbclust(x, FUNcluster = NULL, method = c("silhouette", "wss"),
  diss = NULL, k.max = 10, barfill = "steelblue",
  barcolor = "steelblue", linecolor = "steelblue", print.summary = TRUE,
  ...)

fviz_gap_stat(gap_stat, linecolor = "steelblue", maxSE = list(method =
  "firstmax", SE.factor = 1))
}
\arguments{
\item{object}{an object of class "partition" created by the functions pam(), clara() or fanny() 
in cluster package; "kmeans" [in stats package]; "dbscan" [in fpc package]; "Mclust" [in mclust]; 
"hkmeans", "eclust" [in factoextra]. 
Possible value are also any list object with data and cluster components 
(e.g.: object = list(data = mydata, cluster = myclust)).}

\item{data}{the data that has been used for clustering. Required only when object is a class of kmeans or dbscan.}

\item{stand}{logical value; if TRUE, data is standardized before principal component analysis}

\item{geom}{a text specifying the geometry to be used for the graph. 
Allowed values are the combination of c("point", "text"). 
Use "point" (to show only points);  "text" to show only labels; c("point", "text") to show both types.}

\item{show.clust.cent}{logical; if TRUE, shows cluster centers}

\item{frame}{logical value; if TRUE, draws outline around points of each cluster}

\item{frame.type}{Character specifying frame type. 
Possible values are 'convex' or types supporeted by \code{ggplot2::stat_ellipse} 
including one of c("t", "norm", "euclid").}

\item{frame.level}{Passed for \code{ggplot2::stat_ellipse} 's level. Ignored in 'convex'. 
Default value is 0.95.}

\item{frame.alpha}{Alpha for frame specifying the transparency level of fill color.}

\item{pointsize}{the size of points}

\item{labelsize}{font size for the labels}

\item{jitter}{a parameter used to jitter the points in order to reduce overplotting. 
It's a list containing the objects what, width and height (i.e jitter = list(what, width, height)). 
\itemize{
\item what: the element to be jittered. Possible values are "point" or "p"; "label" or "l"; "both" or "b".
\item width: degree of jitter in x direction
\item height: degree of jitter in y direction
}}

\item{outlier.color, outlier.shape}{the color and the shape of outliers. 
Outliers can be detected only in DBSCAN clustering.}

\item{sil.obj}{an object of class silhouette [from cluster package]}

\item{label}{logical value. If true, x axis tick labels are shown}

\item{print.summary}{logical value. If true a summary of cluster silhouettes are printed in 
fviz_silhouette(); or the optimal number of clusters are printed in fviz_nbclust().}

\item{x}{numeric matrix or data frame. In the function fviz_nbclust(), x can be the 
results of the function NbClust().}

\item{FUNcluster}{a partitioning function which accepts as first argument 
a (data) matrix like x, second argument, say k, k >= 2, the number of clusters desired, 
and returns a list with a component named cluster which contains the grouping 
of observations. For example, kmeans, pam, clara, fanny, .... This is not required when x is 
an output of the function NbClust().}

\item{method}{the method to be used for estimating the optimal number of clusters. 
Possible values are "silhouette" (for average silhouette width) 
and "wss" (for total within sum of square)}

\item{diss}{dist object as produced by dist(), i.e.: diss = dist(x, method = "euclidean"). 
Used to compute the average silhouette width of clusters,
the within sum of square and hierarchical clustering. If NULL, dist(x) is computed with the default method = "euclidean"}

\item{k.max}{the maximum number of clusters to consider, must be at least two}

\item{barfill, barcolor}{fill color and outline color for bars}

\item{linecolor}{color for lines}

\item{...}{optionally further arguments for FUNcluster()}

\item{gap_stat}{an object of class "clusGap" returned by the 
function clusGap() [in cluster package]}

\item{maxSE}{a list containing the parameters (method and SE.factor) for determining the location of the maximum of the gap statistic 
(Read the documentation ?cluster::maxSE). Allowed values for maxSE$method include: 
\itemize{
\item "globalmax": simply corresponds to the global maximum, i.e., is which.max(gap)
\item "firstmax": gives the location of the first local maximum
\item "Tibs2001SEmax": uses the criterion, Tibshirani et al (2001) proposed: 
"the smallest k such that gap(k) >= gap(k+1) - s_{k+1}". 
It's also possible to use "the smallest k such that gap(k) >= gap(k+1) - SE.factor*s_{k+1}" 
where SE.factor is a numeric value which can be 1 (default), 2, 3, etc.
\item see ?cluster::maxSE for more options
}}
}
\value{
\itemize{
\item fviz_cluster, fviz_silhouette, fviz_nbclust, fviz_gap_stat: return a ggplot2
}
}
\description{
\itemize{
\item{fviz_cluster(): Draws the result of partitioning methods 
including kmeans [stats package]; pam, clara and fanny [cluster package]; dbscan [fpc package]; 
Mclust [mclust package]; HCPC [FactoMineR]; hkmeans [factoextra]. 
Observations are represented by points in the plot, using principal components if ncol(data) > 2. 
An ellipse is drawn around each cluster.}
\item{fviz_silhouette(): Draws the result of silhouette() [cluster package]}
\item{fviz_nbclust(): Dertemines and visualize the optimal number of clusters}
\item{fviz_gap_stat(): Visualize the gap statistic generated by the function clusGap() [in cluster package]. 
The optimal number of clusters is specified using the "firstmax" method (?cluster::clustGap).}
}
}
\examples{
\donttest{
set.seed(123)

# Data preparation
# +++++++++++++++
data("iris")
head(iris)
# Remove species column (5) and scale the data
iris.scaled <- scale(iris[, -5])

# K-means clustering
# +++++++++++++++++++++
km.res <- kmeans(iris.scaled, 3, nstart = 25)

# Visualize kmeans clustering
fviz_cluster(km.res, iris[, -5])
# Change frame type
fviz_cluster(km.res, iris[, -5], frame.type = "norm")
# Remove ellipse fill color and change frame level
fviz_cluster(km.res, iris[, -5], frame.type = "norm",
            frame.alpha = 0, frame.level = 0.7)
# Show points only
fviz_cluster(km.res, iris[, -5], geom = "point")
# Show text only
fviz_cluster(km.res, iris[, -5], geom = "text")
# Change the color and theme
fviz_cluster(km.res, iris[, -5]) + 
 scale_color_brewer(palette = "Set2")+
 scale_fill_brewer(palette = "Set2") +
 theme_minimal()
 
 
# PAM clustering
# ++++++++++++++++++++
pam.res <- pam(iris.scaled, 3)
 # Visualize pam clustering
fviz_cluster(pam.res, geom = "point", frame.type = "norm")

# Hierarchical clustering
# ++++++++++++++++++++++++
# Compute pairewise distance matrices
dist.res <- dist(iris.scaled, method = "euclidean")
# Hierarchical clustering results
hc <- hclust(dist.res, method = "complete")

# Visualization of hclust
plot(hc, labels = FALSE, hang = -1)
# Add rectangle around 3 groups
rect.hclust(hc, k = 3, border = 2:4) 

# Cut into 3 groups
hc.cut <- cutree(hc, k = 3)
hc.cut
# Use hcut() which compute hclust and cut the tree
hcut(iris.scaled, k = 3, hc_method = "complete")
# Silhouette plots
# ++++++++++++++++++++++++++++++
# cluster package required
library(cluster)

# Silhouhette for kmeans
sil <- silhouette(km.res$cluster, dist(iris.scaled))
fviz_silhouette(sil)
# Silhouette for PAM
fviz_silhouette(silhouette(pam.res))
# Silhouette for hierarchical clustering
fviz_silhouette(silhouette(hc.cut, dist.res))


# Optimal number of clusters in the data
# ++++++++++++++++++++++++++++++++++++++
### Elbow method (look at the knee)
# Elbow method for kmeans
fviz_nbclust(iris.scaled, kmeans, method = "wss") +
geom_vline(xintercept = 3, linetype = 2)
# Elbow method for PAM
fviz_nbclust(iris.scaled, pam, method = "wss") +
geom_vline(xintercept = 3, linetype = 2)
# Elbow method for hierarchical clustering
fviz_nbclust(iris.scaled, hcut, method = "wss") + 
geom_vline(xintercept = 3, linetype = 2)

### Average silhouette method
# Average silhouette for kmeans
fviz_nbclust(iris.scaled, kmeans, method = "silhouette")
# Average silhouette for pam
fviz_nbclust(iris.scaled, pam, method = "silhouette")
# Average silhouette for hierarchical clustering
fviz_nbclust(iris.scaled, hcut, method = "silhouette")

### Gap statistic
library(cluster)
set.seed(123)
# Compute gap statistic for kmeans
gap_stat <- clusGap(iris.scaled, FUN = kmeans, nstart = 25,
 K.max = 10, B = 50)
 print(gap_stat, method = "firstmax")
fviz_gap_stat(gap_stat)
# Gap statistic for pam
gap_stat <- clusGap(iris.scaled, FUN = pam, K.max = 10, B = 50)
fviz_gap_stat(gap_stat)
# Gap statistic for hierarchical clustering
gap_stat <- clusGap(iris.scaled, FUN = hc, K.max = 10, B = 50)
fviz_gap_stat(gap_stat)
 
}

}

