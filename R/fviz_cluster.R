#' @include eigenvalue.R get_pca.R
 NULL
#' Visualize clustering results
#' @description 
#' \itemize{
#' \item{fviz_cluster(): Draws the result of partitioning methods 
#' including kmeans [stats package]; pam, clara and fanny [cluster package]; dbscan [fpc package]; 
#' Mclust [mclust package]; HCPC [FactoMineR]; hkmeans [factoextra]. 
#' Observations are represented by points in the plot, using principal components if ncol(data) > 2. 
#' An ellipse is drawn around each cluster.}
#' \item{fviz_silhouette(): Draws the result of silhouette() [cluster package]}
#' \item{fviz_nbclust(): Dertemines and visualize the optimal number of clusters}
#' \item{fviz_gap_stat(): Visualize the gap statistic generated by the function clusGap() [in cluster package]. 
#' The optimal number of clusters is specified using the "firstmax" method (?cluster::clustGap).}
#' \item{hcut(): Computes hierarchical clustering and cut the tree into k clusters. The cluster numbers 
#' of obseravtions are returned.}
#' }
#' @param object an object of class "partition" created by the functions pam(), clara() or fanny() 
#' in cluster package; "kmeans" [in stats package]; "dbscan" [in fpc package]; "Mclust" [in mclust]. 
#' Possible value are also any list object with data and cluster components 
#' (e.g.: object = list(data = mydata, cluster = myclust)).
#' @param data the data that has been used for clustering. Required only when object is a class of kmeans or dbscan.
#' @param stand logical value; if TRUE, data is standardized before principal component analysis
#' @param geom a text specifying the geometry to be used for the graph. 
#' Allowed values are the combination of c("point", "text"). 
#' Use "point" (to show only points);  "text" to show only labels; c("point", "text") to show both types.
#' @param show.clust.cent logical; if TRUE, shows cluster centers
#' @param frame logical value; if TRUE, draws outline around points of each cluster 
#' @param frame.type Character specifying frame type. 
#' Possible values are 'convex' or types supporeted by \code{ggplot2::stat_ellipse} 
#' including one of c("t", "norm", "euclid").
#' @param frame.level Passed for \code{ggplot2::stat_ellipse} 's level. Ignored in 'convex'. 
#' Default value is 0.95.
#' @param frame.alpha Alpha for frame specifying the transparency level of fill color. 
#' @param labelsize font size for the labels
#' @param pointsize the size of points
#' @param jitter a parameter used to jitter the points in order to reduce overplotting. 
#' It's a list containing the objects what, width and height (i.e jitter = list(what, width, height)). 
#' \itemize{
#' \item what: the element to be jittered. Possible values are "point" or "p"; "label" or "l"; "both" or "b".
#' \item width: degree of jitter in x direction
#' \item height: degree of jitter in y direction
#' }
#' @param outlier.color,outlier.shape the color and the shape of outliers. 
#' Outliers can be detected only in DBSCAN clustering.
#' 
#' @return 
#' \itemize{
#' \item fviz_cluster, fviz_silhouette, fviz_nbclust, fviz_gap_stat: return a ggplot2
#' \item hcut: returns cluster numbers of observations
#' }
#' 
#' @examples 
#' \donttest{
#' set.seed(123)
#' 
#' # Data preparation
#' # +++++++++++++++
#' data("iris")
#' head(iris)
#' # Remove species column (5) and scale the data
#' iris.scaled <- scale(iris[, -5])
#' 
#' # K-means clustering
#' # +++++++++++++++++++++
#' km.res <- kmeans(iris.scaled, 3, nstart = 25)
#' 
#' # Visualize kmeans clustering
#' fviz_cluster(km.res, iris[, -5])
#' # Change frame type
#' fviz_cluster(km.res, iris[, -5], frame.type = "norm")
#' # Remove ellipse fill color and change frame level
#' fviz_cluster(km.res, iris[, -5], frame.type = "norm",
#'             frame.alpha = 0, frame.level = 0.7)
#' # Show points only
#' fviz_cluster(km.res, iris[, -5], geom = "point")
#' # Show text only
#' fviz_cluster(km.res, iris[, -5], geom = "text")
#'# Change the color and theme
#'fviz_cluster(km.res, iris[, -5]) + 
#'  scale_color_brewer(palette = "Set2")+
#'  scale_fill_brewer(palette = "Set2") +
#'  theme_minimal()
#'  
#'  
#' # PAM clustering
#' # ++++++++++++++++++++
#' pam.res <- pam(iris.scaled, 3)
#'  # Visualize pam clustering
#' fviz_cluster(pam.res, geom = "point", frame.type = "norm")
#' 
#' # Hierarchical clustering
#' # ++++++++++++++++++++++++
#' # Compute pairewise distance matrices
#' dist.res <- dist(iris.scaled, method = "euclidean")
#' # Hierarchical clustering results
#' hc <- hclust(dist.res, method = "complete")
#' 
#' # Visualization of hclust
#' plot(hc, labels = FALSE, hang = -1)
#' # Add rectangle around 3 groups
#' rect.hclust(hc, k = 3, border = 2:4) 
#' 
#' # Cut into 3 groups
#' hc.cut <- cutree(hc, k = 3)
#' hc.cut
#' # Use hcut() which compute hclust and cut the tree
#' hcut(iris.scaled, k = 3, hc_method = "complete")

#' # Silhouette plots
#' # ++++++++++++++++++++++++++++++
#' # cluster package required
#' library(cluster)
#' 
#' # Silhouhette for kmeans
#' sil <- silhouette(km.res$cluster, dist(iris.scaled))
#' fviz_silhouette(sil)
#' # Silhouette for PAM
#' fviz_silhouette(silhouette(pam.res))
#' # Silhouette for hierarchical clustering
#' fviz_silhouette(silhouette(hc.cut, dist.res))
#'
#'
#' # Optimal number of clusters in the data
#' # ++++++++++++++++++++++++++++++++++++++
#' ### Elbow method (look at the knee)
#' # Elbow method for kmeans
#' fviz_nbclust(iris.scaled, kmeans, method = "wss") +
#' geom_vline(xintercept = 3, linetype = 2)
#' # Elbow method for PAM
#' fviz_nbclust(iris.scaled, pam, method = "wss") +
#' geom_vline(xintercept = 3, linetype = 2)
#' # Elbow method for hierarchical clustering
#' fviz_nbclust(iris.scaled, hcut, method = "wss") + 
#' geom_vline(xintercept = 3, linetype = 2)
#' 
#' ### Average silhouette method
#' # Average silhouette for kmeans
#' fviz_nbclust(iris.scaled, kmeans, method = "silhouette")
#' # Average silhouette for pam
#' fviz_nbclust(iris.scaled, pam, method = "silhouette")
#' # Average silhouette for hierarchical clustering
#' fviz_nbclust(iris.scaled, hcut, method = "silhouette")
#' 
#' ### Gap statistic
#' library(cluster)
#' set.seed(123)
#' # Compute gap statistic for kmeans
#' gap_stat <- clusGap(iris.scaled, FUN = kmeans, nstart = 25,
#'  K.max = 10, B = 50)
#'  print(gap_stat, method = "firstmax")
#' fviz_gap_stat(gap_stat)
#' # Gap statistic for pam
#' gap_stat <- clusGap(iris.scaled, FUN = pam, K.max = 10, B = 50)
#' fviz_gap_stat(gap_stat)
#' # Gap statistic for hierarchical clustering
#' gap_stat <- clusGap(iris.scaled, FUN = hc, K.max = 10, B = 50)
#' fviz_gap_stat(gap_stat)
#'  
#' }
#' 
#' @name fviz_cluster
#' @rdname fviz_cluster
#' @export
fviz_cluster <- function(object, data = NULL, stand = TRUE, 
                         geom = c("point", "text"), 
                         show.clust.cent = TRUE,
                         frame = TRUE, frame.type = "convex", frame.level = 0.95,
                         frame.alpha = 0.2,
                         pointsize = 2, labelsize = 4, 
                         jitter = list(what = "label", width = NULL, height = NULL),
                         outlier.color = "black", outlier.shape = 19){
  # object from cluster package
  if(inherits(object, c("partition", "hkmeans"))) data <- object$data
  # Object from kmeans (stats package)
  else if(inherits(object, "kmeans") | inherits(object, "dbscan")){
    if(is.null(data)) stop("data is required for plotting kmeans/dbscan clusters")
  } 
  # Object from mclust package
  else if(inherits(object, "Mclust")) {
    object$cluster <- object$classification
    data <- object$data
  }
  # HCPC in FactoMineR
  else if(inherits(object, "HCPC")) {
    data <- object$data.clust[, -ncol(object$data.clust), drop = FALSE]
    object$cluster <- as.vector(object$data.clust$clust)
  }
  # Any obects containing data and cluster elements
  else if(!is.null(object$data) & !is.null(object$cluster)){
    data <- object$data
    cluster <- object$cluster
  }
  else stop("Can't handle an object of class ", class(object))
  if(stand) data <- scale(data)
  cluster <- as.factor(object$cluster)
  
  pca_performed <- FALSE
  
  # Prepare the data for plotting
  # ++++++++++++++++++++++++
  # PCA is performed depending on the number of variables
  if(inherits(data, c("matrix", "data.frame"))){
    # ncol(data) > 2 --> PCA
    if(ncol(data)>2){
    pca <- stats::prcomp(data, scale = FALSE, center = FALSE)
    ind  <- facto_summarize(pca, element = "ind", result = "coord", axes = 1:2)
    pca_performed = TRUE
    }
    # PCA is not performed
    else if(ncol(data) == 2){
      ind <- as.data.frame(data)
      ind <- cbind.data.frame(name = rownames(ind), ind)
    }
    colnames(ind)[2:3] <-  c("x", "y")
    label_coord <- ind
  }
  else stop("A data of class ", class(data), " is not supported.")
  
  # Plot data and labels
  # ++++++++++++++++++++++++
  label = FALSE
  if("text" %in% geom) label = TRUE
  if(!("point" %in% geom)) pointsize = 0
  if(is.null(jitter$what)) jitter$what <- "label"
 
  # Jittering
  if(jitter$what %in% c("both", "b")) label_coord <- ind <- .jitter(ind, jitter)
  else if(jitter$what %in% c("point", "p")) ind <- .jitter(ind, jitter)
  else if(jitter$what %in% c("label", "l")) label_coord <- .jitter(label_coord, jitter)
  
  plot.data <- cbind.data.frame(ind, cluster = cluster)
  label_coord <- cbind.data.frame(label_coord, cluster = cluster)
  
  # IF DBSCAN: cluster 0 is outliers. We don't want to make ellipse around
  # these observations. Let's remove them. They will be added to the plot later
  is_outliers = FALSE
  if(inherits(object, "dbscan")){
    outliers <- which(cluster == 0)
    if(length(outliers) > 0){
      is_outliers = TRUE
      outliers_data <- plot.data[outliers, , drop = FALSE]
      outliers_labs <- label_coord[outliers, , drop = FALSE]
      
      ind <- ind[-outliers, , drop = FALSE]
      cluster <- cluster[-outliers]
      plot.data <- plot.data[-outliers, , drop = FALSE]
      label_coord <- label_coord[-outliers, , drop = FALSE]
    }
  }
  
  # Plot
  # ++++++++++++++++++++++++
  p <- ggplot()
  if("point" %in% geom) 
    p <- p+geom_point(data = plot.data , 
                      aes_string('x', 'y', color="cluster", shape = "cluster"),
                      size = pointsize)
  if("text" %in% geom)
    p <- p + geom_text(data = label_coord, 
                       aes_string('x', 'y', label = 'name', color="cluster"),  
                       size = labelsize, vjust = -0.7)
  
  # Add cluster center
  clustcent <- stats::aggregate(ind[, 2:3], by=list(cluster=cluster), mean)
  colnames(clustcent) <- c("cluster", "x", "y")
  if(show.clust.cent){
    if("point" %in% geom) 
      p <- p + geom_point(data=clustcent,
                          aes_string('x', 'y', color="cluster", shape="cluster"),
                          size=pointsize*2)    
    if("text" %in% geom)
      p <- p + geom_text(data=clustcent, 
                         aes_string('x', 'y', color="cluster"),
                         label=clustcent$cluster, size=labelsize*1.2, vjust=-1)
  }
  
  # Add frame
  if(frame){
    if (frame.type == 'convex'){
      frame.data <- .cluster_chull(ind[, c("x", "y")], cluster)
      mapping = aes_string(x = "x", y = "y", colour ="cluster", fill = "cluster")
      p <- p + ggplot2::geom_polygon(data = frame.data,  mapping = mapping, alpha = frame.alpha)
    }
    else if (frame.type %in% c('t', 'norm', 'euclid')) {
        mapping = aes_string(x = "x", y = "y", colour = "cluster", fill = "cluster")
        p <- p + ggplot2::stat_ellipse(mapping = mapping, data = plot.data,
                                       level = frame.level, type = frame.type,
                                       geom = 'polygon', alpha = frame.alpha)
    }
  }
  
  # Add outliers (can exist only in dbscan)
  if(is_outliers)
    p <- .add_outliers(p, outliers_data, outliers_labs, outlier.color, outlier.shape,
                  pointsize, labelsize, geom)
  
  
  # Plot titles
  # ++++++++++++++++++++++++
  if(pca_performed){
    eig <- get_eigenvalue(pca)[,2]
    xlab = paste0("Dim", 1, " (", round(eig[1],1), "%)") 
    ylab = paste0("Dim", 2, " (", round(eig[2], 1),"%)")
  }
  else{
    xlab <- colnames(data)[1]
    ylab <- colnames(data)[2]
  }
  p <- p + labs(title = "Cluster plot", x = xlab, y = ylab)

  p
}

#' @rdname fviz_cluster
#' @param sil.obj an object of class silhouette [from cluster package]
#' @param label logical value. If true, x axis tick labels are shown
#' @param print.summary logical value. If true a summary of cluster silhouettes are printed in 
#' fviz_silhouette(); or the optimal number of clusters are printed in fviz_nbclust().
#' @rdname fviz_cluster
#' @export
fviz_silhouette <- function(sil.obj, label = FALSE, print.summary = TRUE){
  df <- as.data.frame(sil.obj[, 1:3])
  # order by cluster and by sil_width
  df <- df[order(df$cluster, -df$sil_width), ]
  if(!is.null(rownames(sil.obj))) df$nam <- rownames(df)
  else df$name <- as.factor(1:nrow(df))
  df$cluster <- as.factor(df$cluster)
  mapping <- aes_string(x = "name", y = "sil_width", 
                        color = "cluster", fill = "cluster")
  p <- ggplot(df, mapping) +
    geom_bar(stat = "identity") +
    labs(y = "Silhouette width Si", x = "",
         title = paste0("Clusters silhouette plot ",
                        "\n Average silhouette width: ", 
                        round(mean(df$sil_width), 2)))+
    ggplot2::ylim(c(NA, 1))
  # Labels
  if(!label) p <- p + theme(axis.text.x = element_blank(), 
                            axis.ticks.x = element_blank())
  else if(label)
    p <- p + theme(axis.text.x = element_text(angle=45))
  
  # Print summary
  ave <- tapply(df$sil_width, df$cluster, mean)
  n <- tapply(df$cluster, df$cluster, length)
  sil.sum <- data.frame(cluster = names(ave), size = n,
                      ave.sil.width = round(ave,2))
  if(print.summary) print(sil.sum)
  
  p
}


#' @rdname fviz_cluster
#' @param x numeric matrix or data frame. In the function fviz_nbclust(), x can be the 
#' results of the function NbClust(). 
#' @param method the method to be used for estimating the optimal number of clusters. 
#' Possible values are "silhouette" (for average silhouette width) 
#' and "wss" (for total within sum of square)
#' @param FUNcluster a partitioning function which accepts as first argument 
#' a (data) matrix like x, second argument, say k, k >= 2, the number of clusters desired, 
#' and returns a list with a component named cluster which contains the grouping 
#' of observations. For example, kmeans, pam, clara, fanny, .... This is not required when x is 
#' an output of the function NbClust().
#' @param diss dist object as produced by dist(), i.e.: diss = dist(x, method = "euclidean"). 
#' Used to compute the average silhouette width of clusters,
#' the within sum of square and hierarchical clustering. If NULL, dist(x) is computed with the default method = "euclidean"
#' @param k.max the maximum number of clusters to consider, must be at least two
#' @param barfill,barcolor fill color and outline color for bars
#' @param linecolor color for lines
#' @param ... optionally further arguments for FUNcluster()
#' @export
fviz_nbclust <- function (x, FUNcluster = NULL, method = c("silhouette", "wss"),
                          diss = NULL, k.max = 10, 
                          barfill="steelblue", barcolor="steelblue", 
                          linecolor = "steelblue", print.summary = TRUE,  ...) 
  {
  
  if(k.max < 2) stop("k.max must bet > = 2")
  
  # x is an object created by the function NbClust() [NbClust package]
  if(inherits(x, "list") & "Best.nc" %in% names(x)){
      best_nc <- x$Best.nc
      if(class(best_nc) == "numeric") print(best_nc)
      else if(class(best_nc) == "matrix") 
        .viz_NbClust(x, print.summary, barfill, barcolor)
  }
  else if(is.null(FUNcluster)) stop("The argument FUNcluster is required. ",
                                    "Possible values are kmeans, pam, hcut, clara, ...")
  else{

      if (is.data.frame(x)) x <- as.matrix(x)
      if(is.null(diss)) diss <- dist(x)
      method <- method[1]
      
      v <- rep(0, k.max)
      if(method == "silhouette"){
        for(i in 2:k.max){
          clust <- FUNcluster(x, i, ...)
          v[i] <- .get_ave_sil_width(diss, clust$cluster)
        }
      }
      else if(method == "wss"){
        for(i in 1:k.max){
          clust <- FUNcluster(x, i, ...)
          v[i] <- .get_withinSS(diss, clust$cluster)
        }
      }
      
      df <- data.frame(clusters = as.factor(1:k.max), y = v)
      
      ylab <- "Total Within Sum of Square"
      if(method == "silhouette") ylab <- "Average silhouette width"
      
      p <- ggplot(df, aes_string( x = "clusters", y = "y", group = 1)) +
        geom_point(color = linecolor) +
        geom_line(color = linecolor) +
        labs(y = ylab, x = "Number of clusters k",
             title = "Optimal number of clusters")
      
      if(method == "silhouette") 
        p <- p + geom_vline(xintercept = which.max(v), linetype=2, color = linecolor)
      return(p)
  }
}

#' @rdname fviz_cluster
#' @param gap_stat an object of class "clusGap" returned by the 
#' function clusGap() [in cluster package]
#' @param maxSE a list containing the parameters (method and SE.factor) for determining the location of the maximum of the gap statistic 
#' (Read the documentation ?cluster::maxSE). Allowed values for maxSE$method include: 
#' \itemize{
#' \item "globalmax": simply corresponds to the global maximum, i.e., is which.max(gap)
#' \item "firstmax": gives the location of the first local maximum
#' \item "Tibs2001SEmax": uses the criterion, Tibshirani et al (2001) proposed: 
#' "the smallest k such that gap(k) >= gap(k+1) - s_{k+1}". 
#' It's also possible to use "the smallest k such that gap(k) >= gap(k+1) - SE.factor*s_{k+1}" 
#' where SE.factor is a numeric value which can be 1 (default), 2, 3, etc.
#' \item see ?cluster::maxSE for more options
#' }
#' 
#'  
#' @export
fviz_gap_stat <- function(gap_stat,  linecolor = "steelblue",
                          maxSE = list(method = "firstmax", SE.factor = 1)){
  if(!inherits(gap_stat, "clusGap"))
    stop("Only an object of class clusGap is allowed. (cluster package)")
  if(is.list(maxSE)){
    if(is.null(maxSE$method)) maxSE$method = "firstmax"
    if(is.null(maxSE$SE.factor)) maxSE$SE.factor = 1
  }
  else stop("The argument maxSE must be a list containing the parameters method and SE.factor")
  
  # first local max
  gap <- gap_stat$Tab[, "gap"]
  se <- gap_stat$Tab[, "SE.sim"]
  decr <- diff(gap) <= 0
  k <- .maxSE(gap, se, method = maxSE$method, SE.factor = maxSE$SE.factor)
  
  #k <- length(gap)
  #k = if (any(decr)) which.max(decr) else k

  df <- as.data.frame(gap_stat$Tab)
  df$clusters <- as.factor(1:nrow(df))
  df$ymin <- gap-se
  df$ymax <- gap + se
  p <- ggplot(df, aes_string( x = "clusters", y = "gap", group = 1)) +
    ggplot2::geom_errorbar(aes_string(ymin="ymin", ymax="ymax"), width=.2, color = linecolor)+
    geom_point(color = linecolor) +
    geom_line(color = linecolor) +
    geom_vline(xintercept = k, linetype=2, color = linecolor)+
    labs(y = "Gap statistic (k)", x = "Number of clusters k",
         title = "Otimal number of clusters")
  p
}



#' @rdname fviz_cluster
#' @param k the number of clusters to be generated
#' @param hc_method the agglomeration method to be used (?hclust): 
#' "ward.D", "ward.D2", "single", "complete", "average", ...
#' @export
hcut <- function(x, k = 1, diss = NULL, hc_method = "complete"){
  if(is.null(diss)) diss <- dist(x)
  hc <- stats::hclust(diss, method = hc_method)
  hc.cut <- stats::cutree(hc, k = k)
  list(cluster = hc.cut)
}
 

# Get the average silhouette width
# ++++++++++++++++++++++++++
# Cluster package required
# d: dist object
# cluster: cluster number of observation
.get_ave_sil_width <- function(d, cluster){
  if (!requireNamespace("cluster", quietly = TRUE)) {
    stop("cluster package needed for this function to work. Please install it.")
  }
  ss <- cluster::silhouette(cluster, d)
  mean(ss[, 3])
}

# Get total within sum of square
# +++++++++++++++++++++++++++++
# d: dist object
# cluster: cluster number of observation
.get_withinSS <- function(d, cluster){
  d <- stats::as.dist(d)
  cn <- max(cluster)
  clusterf <- as.factor(cluster)
  clusterl <- levels(clusterf)
  cnn <- length(clusterl)
  
  if (cn != cnn) {
    warning("cluster renumbered because maximum != number of clusters")
    for (i in 1:cnn) cluster[clusterf == clusterl[i]] <- i
    cn <- cnn
  }
  cwn <- cn
  # Compute total within sum of square
  dmat <- as.matrix(d)
  within.cluster.ss <- 0
  for (i in 1:cn) {
    cluster.size <- sum(cluster == i)
    di <- as.dist(dmat[cluster == i, cluster == i])
    within.cluster.ss <- within.cluster.ss + sum(di^2)/cluster.size
  }
  within.cluster.ss
}



# Compute convex hull for each cluster
# ++++++++++++++++++++++++++++++++
# x,y: numeric vector corresponding to the coordinates of points
# cluster: groups of observations
.cluster_chull <- function(x, cluster){
  cluster <- as.factor(cluster)
  levs <- levels(cluster)
  res = NULL
  for(lev in levs){
    dd <- x[which(cluster == lev), , drop = FALSE]
    cc <- chull(dd)
    res <- rbind(res, cbind(dd[cc, , drop = FALSE], cluster = rep(lev, length(cc))))
  }
  as.data.frame(res)
}

# Add outliers to cluster plot (for dbscan only)
.add_outliers <-function(p, outliers_data, outliers_labs, 
                         outlier.color = "black", outlier.shape = 19,
                         pointsize = 2, labelsize = 4, geom = c("point", "text"))
  {
  
  if("point" %in% geom) 
    p <-  p + geom_point(data = outliers_data, 
                      aes_string('x', 'y'),
                      size = pointsize, color = outlier.color, shape = outlier.shape)
  if("text" %in% geom)
    p <- p + geom_text(data = outliers_labs, 
                       aes_string('x', 'y', label = 'name'),  
                       size = labelsize, vjust = -0.7, color = outlier.color, shape = outlier.shape)
  return(p)
}

# Visualization of the output returned by the function
# NbClust()
# x : an object generated by the function NbClust()
.viz_NbClust <- function(x, print.summary = TRUE,
                         barfill = "steelblue", barcolor = "steelblue")
  {
     best_nc <- x$Best.nc
    if(class(best_nc) == "numeric") print(best_nc)
     else if(class(best_nc) == "matrix"){
    best_nc <- as.data.frame(t(best_nc))
    best_nc$Number_clusters <- as.factor(best_nc$Number_clusters)
    
    # Summary
    if(print.summary){
      ss <- summary(best_nc$Number_clusters)
      cat ("Among all indices: \n===================\n")
      for(i in 1 :length(ss)){
        cat("*", ss[i], "proposed ", names(ss)[i], "as the best number of clusters\n" )
      }
      cat("\nConclusion\n=========================\n")
      cat("* Accoridng to the majority rule, the best number of clusters is ",
          names(which.max(ss)),  ".\n\n")
    }
    p <- ggplot(best_nc, aes_string(x= "Number_clusters")) + 
      ggplot2::geom_histogram(fill = barfill, color = barcolor)+
      labs(x = "Number of clusters k", y = "Frequency among all indices",
           title = paste0("Optimal number of clusters - k = ", names(which.max(ss)) ))
    
    return(p)
  }
}


#  Determines the location of the maximum of f see ?cluster::maxSE
# +++++++++++++++++++++++++++++++++++++++++++
# f: numeric vector containing the gap statistic
# SE.f : standard error of the gap statistic
# method : character string indicating how the “optimal” number of clusters, k^, 
  # is computed from the gap statistics (and their standard deviations), 
  # or more generally how the location k^ of the maximum of f[k] should be determined.
# SE.factor:  Determining the optimal number of clusters, Tibshirani et al. proposed the “1 S.E.”-rule.
.maxSE <- function (f, SE.f, method = c("firstSEmax", "Tibs2001SEmax", 
                                        "globalSEmax", "firstmax", "globalmax"), SE.factor = 1) 
{
  method <- match.arg(method)
  stopifnot((K <- length(f)) >= 1, K == length(SE.f), SE.f >= 
              0, SE.factor >= 0)
  fSE <- SE.factor * SE.f
  switch(method, firstmax = {
    decr <- diff(f) <= 0
    if (any(decr)) which.max(decr) else K
  }, globalmax = {
    which.max(f)
  }, Tibs2001SEmax = {
    g.s <- f - fSE
    if (any(mp <- f[-K] >= g.s[-1])) which.max(mp) else K
  }, firstSEmax = {
    decr <- diff(f) <= 0
    nc <- if (any(decr)) which.max(decr) else K
    if (any(mp <- f[seq_len(nc - 1)] >= f[nc] - fSE[nc])) which(mp)[1] else nc
  }, globalSEmax = {
    nc <- which.max(f)
    if (any(mp <- f[seq_len(nc - 1)] >= f[nc] - fSE[nc])) which(mp)[1] else nc
  })
}
